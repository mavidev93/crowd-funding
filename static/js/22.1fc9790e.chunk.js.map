{"version":3,"sources":["../../../src/index.ts","../../src/config.ts","../../src/walletConnectV1adapter.ts","../../src/baseEvmAdapter.ts"],"names":["WALLET_CONNECT_EXTENSION_ADAPTERS","name","chains","CHAIN_NAMESPACES","logo","mobile","native","universal","desktop","constructor","options","WALLET_ADAPTERS","WALLET_CONNECT_V1","ADAPTER_NAMESPACES","EIP155","ADAPTER_CATEGORY","EXTERNAL","ADAPTER_STATUS","NOT_READY","uri","extensionAdapters","connected","provider","wcProvider","init","getChainConfig","config","chainConfig","connector","ADAPTER_EVENTS","log","accounts","chainId","connect","WalletInitializationError","skipLookupNetwork","skipNetworkSwitching","adapter","reject","payload","resolve","error","WalletLoginError","setAdapterSettings","getUserInfo","disconnect","cleanup","addChain","networkSwitch","appOrigin","window","hostname","switchChain","currentChainConfig","newChainConfig","lookup","createNewSession","opts","forceNewSession","parseInt","onConnectHandler","connectedChainConfig","displayName","isCustomUi","reconnected","rehydrated","subscribeEvents","getWalletConnectInstance","walletConnectOptions","authenticateUser","method","existingToken","getSavedToken","checkIfTokenIsExpired","idToken","domain","address","version","nonce","Math","issuedAt","signChallenge","challenge","params","signedMessage","verifySignedChallenge","saveToken","clearToken"],"mappings":"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","file":"static/js/22.1fc9790e.chunk.js","sourcesContent":["import Connector from \"@walletconnect/core\";\nimport * as cryptoLib from \"@walletconnect/iso-crypto\";\nclass WalletConnect extends Connector {\n    constructor(connectorOpts, pushServerOpts) {\n        super({\n            cryptoLib,\n            connectorOpts,\n            pushServerOpts,\n        });\n    }\n}\nexport default WalletConnect;\n//# sourceMappingURL=index.js.map","import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport WalletConnect from '@walletconnect/client';\nimport { CHAIN_NAMESPACES, WALLET_ADAPTERS, ADAPTER_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, getChainConfig, ADAPTER_EVENTS, log, WalletInitializationError, Web3AuthError, WalletLoginError } from '@web3auth/base';\nimport { BaseEvmAdapter } from '@web3auth/base-evm-adapter';\nimport { WalletConnectProvider } from '@web3auth/ethereum-provider';\n\nconst WALLET_CONNECT_EXTENSION_ADAPTERS = [{\n  name: \"Rainbow\",\n  chains: [CHAIN_NAMESPACES.EIP155],\n  logo: \"https://images.web3auth.io/login-rainbow.svg\",\n  mobile: {\n    native: \"rainbow:\",\n    universal: \"https://rnbwapp.com\"\n  },\n  desktop: {\n    native: \"\",\n    universal: \"\"\n  }\n}, {\n  name: \"MetaMask\",\n  chains: [CHAIN_NAMESPACES.EIP155],\n  logo: \"https://images.web3auth.io/login-metamask.svg\",\n  mobile: {\n    native: \"metamask:\",\n    universal: \"https://metamask.app.link\"\n  },\n  desktop: {\n    native: \"\",\n    universal: \"\"\n  }\n}];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nclass WalletConnectV1Adapter extends BaseEvmAdapter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.WALLET_CONNECT_V1);\n\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.EXTERNAL);\n\n    _defineProperty(this, \"adapterOptions\", void 0);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"adapterData\", {\n      uri: \"\",\n      extensionAdapters: WALLET_CONNECT_EXTENSION_ADAPTERS\n    });\n\n    _defineProperty(this, \"connector\", null);\n\n    _defineProperty(this, \"wcProvider\", null);\n\n    _defineProperty(this, \"rehydrated\", false);\n\n    this.adapterOptions = _objectSpread({}, options);\n    this.chainConfig = options.chainConfig || null;\n    this.sessionTime = options.sessionTime || 86400;\n  }\n\n  get connected() {\n    var _this$connector;\n\n    return !!((_this$connector = this.connector) !== null && _this$connector !== void 0 && _this$connector.connected);\n  }\n\n  get provider() {\n    var _this$wcProvider;\n\n    return ((_this$wcProvider = this.wcProvider) === null || _this$wcProvider === void 0 ? void 0 : _this$wcProvider.provider) || null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init() {\n    super.checkInitializationRequirements();\n\n    if (!this.chainConfig) {\n      this.chainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, 1);\n    } // Create a connector\n\n\n    this.connector = this.getWalletConnectInstance();\n    this.wcProvider = new WalletConnectProvider({\n      config: {\n        chainConfig: this.chainConfig\n      },\n      connector: this.connector\n    });\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n    this.status = ADAPTER_STATUS.READY;\n    log.debug(\"initializing wallet connect v1 adapter\");\n\n    if (this.connector.connected) {\n      this.rehydrated = true;\n      await this.onConnectHandler({\n        accounts: this.connector.accounts,\n        chainId: this.connector.chainId\n      });\n    }\n  }\n\n  async connect() {\n    super.checkConnectionRequirements();\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n    if (this.connected) {\n      await this.onConnectHandler({\n        accounts: this.connector.accounts,\n        chainId: this.connector.chainId\n      });\n      return this.provider;\n    }\n\n    if (this.status !== ADAPTER_STATUS.CONNECTING) {\n      var _this$adapterOptions$;\n\n      // for wallet connect qr code modal we have to create a new connector, coz wallet connect internally does not open\n      // modal again on existing instance if connection is pending.\n      if ((_this$adapterOptions$ = this.adapterOptions.adapterSettings) !== null && _this$adapterOptions$ !== void 0 && _this$adapterOptions$.qrcodeModal) {\n        var _this$adapterOptions$2;\n\n        this.connector = this.getWalletConnectInstance();\n        this.wcProvider = new WalletConnectProvider({\n          config: {\n            chainConfig: this.chainConfig,\n            // network switching can be skipped with custom ui\n            skipLookupNetwork: (_this$adapterOptions$2 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$2 === void 0 ? void 0 : _this$adapterOptions$2.skipNetworkSwitching\n          },\n          connector: this.connector\n        });\n      }\n\n      await this.createNewSession();\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, {\n        adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.connector) return reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\")); // for wallet connect default modal.\n\n      this.connector.on(\"modal_closed\", async () => {\n        this.status = ADAPTER_STATUS.READY;\n        this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n        return reject(new Error(\"User closed modal\"));\n      });\n\n      try {\n        // Subscribe to session connection\n        this.connector.on(\"connect\", async (error, payload) => {\n          if (error) {\n            this.emit(ADAPTER_EVENTS.ERRORED, error);\n          }\n\n          log.debug(\"connected event emitted by web3auth\");\n          await this.onConnectHandler(payload.params[0]);\n          return resolve(this.provider);\n        });\n      } catch (error) {\n        log.error(\"Wallet connect v1 adapter error while connecting\", error); // ready again to be connected\n\n        this.status = ADAPTER_STATUS.READY;\n        this.rehydrated = true;\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        reject(error instanceof Web3AuthError ? error : WalletLoginError.connectionError(\"Failed to login with wallet connect: \".concat((error === null || error === void 0 ? void 0 : error.message) || \"\")));\n      }\n    });\n  }\n\n  setAdapterSettings(options) {\n    if (this.status === ADAPTER_STATUS.READY) return;\n\n    if (options !== null && options !== void 0 && options.sessionTime) {\n      this.sessionTime = options.sessionTime;\n    }\n  }\n\n  async getUserInfo() {\n    if (!this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    const {\n      cleanup\n    } = options;\n    if (!this.connector || !this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    await super.disconnect();\n    await this.connector.killSession();\n    this.rehydrated = false;\n\n    if (cleanup) {\n      this.connector = null;\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.wcProvider = null;\n    } else {\n      // ready to connect again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async addChain(chainConfig) {\n    try {\n      var _this$adapterOptions$3;\n\n      if (!this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n      const networkSwitch = (_this$adapterOptions$3 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$3 === void 0 ? void 0 : _this$adapterOptions$3.networkSwitchModal;\n\n      if (networkSwitch) {\n        await networkSwitch.addNetwork({\n          chainConfig,\n          appOrigin: window.location.hostname\n        });\n      }\n\n      await this.wcProvider.addChain(chainConfig);\n    } catch (error) {\n      log.error(error);\n    }\n  }\n\n  async switchChain(connectedChainConfig, chainConfig) {\n    var _this$adapterOptions$4;\n\n    if (!this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    const networkSwitch = (_this$adapterOptions$4 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$4 === void 0 ? void 0 : _this$adapterOptions$4.networkSwitchModal;\n\n    if (networkSwitch) {\n      await networkSwitch.switchNetwork({\n        currentChainConfig: chainConfig,\n        newChainConfig: connectedChainConfig,\n        appOrigin: window.location.hostname\n      });\n    }\n\n    await this.wcProvider.switchChain({\n      chainId: chainConfig.chainId,\n      lookup: false,\n      addChain: false\n    });\n  }\n\n  async createNewSession() {\n    var _this$adapterOptions, _this$adapterOptions$5;\n\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      forceNewSession: false\n    };\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n    if (opts.forceNewSession && this.connector.pending) {\n      await this.connector.killSession();\n    } // for wallet connect qr modal\n\n\n    if ((_this$adapterOptions = this.adapterOptions) !== null && _this$adapterOptions !== void 0 && (_this$adapterOptions$5 = _this$adapterOptions.adapterSettings) !== null && _this$adapterOptions$5 !== void 0 && _this$adapterOptions$5.qrcodeModal) {\n      var _this$chainConfig;\n\n      await this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig = this.chainConfig) === null || _this$chainConfig === void 0 ? void 0 : _this$chainConfig.chainId) || \"0x1\", 16)\n      });\n      return;\n    } // for web3auth qr code modal\n\n\n    return new Promise((resolve, reject) => {\n      var _this$chainConfig2;\n\n      if (!this.connector) return reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\"));\n      log.debug(\"creating new session for web3auth wallet connect\");\n      this.connector.on(\"display_uri\", async (err, payload) => {\n        var _this$connector2;\n\n        if (err) {\n          this.emit(ADAPTER_EVENTS.ERRORED, WalletLoginError.connectionError(\"Failed to display wallet connect qr code\"));\n          return reject(err);\n        }\n\n        const uri = payload.params[0];\n        this.updateAdapterData({\n          uri,\n          extensionAdapters: WALLET_CONNECT_EXTENSION_ADAPTERS\n        });\n        (_this$connector2 = this.connector) === null || _this$connector2 === void 0 ? void 0 : _this$connector2.off(\"display_uri\");\n        return resolve();\n      });\n      this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig2 = this.chainConfig) === null || _this$chainConfig2 === void 0 ? void 0 : _this$chainConfig2.chainId) || \"0x1\", 16)\n      }).catch(error => {\n        log.error(\"error while creating new wallet connect session\", error);\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        return reject(error);\n      });\n    });\n  }\n\n  async onConnectHandler(params) {\n    if (!this.connector || !this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"Chain config is not set\");\n    const {\n      chainId\n    } = params;\n    log.debug(\"connected chainId in hex\");\n\n    if (chainId !== parseInt(this.chainConfig.chainId, 16)) {\n      var _this$adapterOptions$6, _this$adapterOptions2, _this$adapterOptions3;\n\n      const connectedChainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, chainId) || {\n        chainId: \"0x\".concat(chainId.toString(16)),\n        displayName: \"Unknown Network\"\n      };\n      const isCustomUi = (_this$adapterOptions$6 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$6 === void 0 ? void 0 : _this$adapterOptions$6.qrcodeModal; // skipping network is not allowed in default ui. We are use network switching modal for default ui.\n\n      if (!isCustomUi || isCustomUi && !((_this$adapterOptions2 = this.adapterOptions) !== null && _this$adapterOptions2 !== void 0 && (_this$adapterOptions3 = _this$adapterOptions2.adapterSettings) !== null && _this$adapterOptions3 !== void 0 && _this$adapterOptions3.skipNetworkSwitching)) {\n        try {\n          await this.addChain(this.chainConfig);\n          await this.switchChain(connectedChainConfig, this.chainConfig);\n          this.connector = this.getWalletConnectInstance();\n        } catch (error) {\n          log.error(\"error while chain switching\", error); // we need to create a new session since old session is already used and\n          // user needs to login again with correct chain with new qr code.\n\n          await this.createNewSession({\n            forceNewSession: true\n          });\n          this.emit(ADAPTER_EVENTS.ERRORED, WalletInitializationError.fromCode(5000, \"Not connected to correct network. Expected: \".concat(this.chainConfig.displayName, \", Current: \").concat((connectedChainConfig === null || connectedChainConfig === void 0 ? void 0 : connectedChainConfig.displayName) || chainId, \", Please switch to correct network from wallet\")));\n          this.status = ADAPTER_STATUS.READY;\n          this.rehydrated = true;\n          return;\n        }\n      }\n    }\n\n    await this.wcProvider.setupProvider(this.connector);\n    this.subscribeEvents(this.connector);\n    this.status = ADAPTER_STATUS.CONNECTED;\n    this.emit(ADAPTER_EVENTS.CONNECTED, {\n      adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1,\n      reconnected: this.rehydrated\n    });\n  }\n\n  subscribeEvents(connector) {\n    connector.on(\"session_update\", async error => {\n      if (error) {\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n      }\n    });\n  }\n\n  getWalletConnectInstance() {\n    const walletConnectOptions = this.adapterOptions.adapterSettings || {};\n    walletConnectOptions.bridge = walletConnectOptions.bridge || \"https://bridge.walletconnect.org\"; // Create a connector\n\n    return new WalletConnect(walletConnectOptions);\n  }\n\n}\n\nexport { WalletConnectV1Adapter };\n//# sourceMappingURL=walletConnectV1Adapter.esm.js.map\n",null,"import { BaseAdapter, WalletLoginError, ADAPTER_STATUS, getSavedToken, checkIfTokenIsExpired, signChallenge, verifySignedChallenge, saveToken, clearToken } from '@web3auth/base';\n\nclass BaseEvmAdapter extends BaseAdapter {\n  async authenticateUser() {\n    var _this$chainConfig;\n\n    if (!this.provider || !((_this$chainConfig = this.chainConfig) !== null && _this$chainConfig !== void 0 && _this$chainConfig.chainId)) throw WalletLoginError.notConnectedError();\n    const {\n      chainNamespace,\n      chainId\n    } = this.chainConfig;\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    const accounts = await this.provider.request({\n      method: \"eth_accounts\"\n    });\n\n    if (accounts && accounts.length > 0) {\n      const existingToken = getSavedToken(accounts[0], this.name);\n\n      if (existingToken) {\n        const isExpired = checkIfTokenIsExpired(existingToken);\n\n        if (!isExpired) {\n          return {\n            idToken: existingToken\n          };\n        }\n      }\n\n      const payload = {\n        domain: window.location.origin,\n        uri: window.location.href,\n        address: accounts[0],\n        chainId: parseInt(chainId, 16),\n        version: \"1\",\n        nonce: Math.random().toString(36).slice(2),\n        issuedAt: new Date().toISOString()\n      };\n      const challenge = await signChallenge(payload, chainNamespace);\n      const signedMessage = await this.provider.request({\n        method: \"personal_sign\",\n        params: [challenge, accounts[0]]\n      });\n      const idToken = await verifySignedChallenge(chainNamespace, signedMessage, challenge, this.name, this.sessionTime);\n      saveToken(accounts[0], this.name, idToken);\n      return {\n        idToken\n      };\n    }\n\n    throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n  }\n\n  async disconnect() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.disconnectionError(\"Not connected with wallet\");\n    const accounts = await this.provider.request({\n      method: \"eth_accounts\"\n    });\n\n    if (accounts && accounts.length > 0) {\n      clearToken(accounts[0], this.name);\n    }\n  }\n\n}\n\nexport { BaseEvmAdapter };\n//# sourceMappingURL=baseEvmAdapter.esm.js.map\n"],"sourceRoot":""}